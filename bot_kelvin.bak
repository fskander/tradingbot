# --- TIMESTAMP LOGGER ---
import builtins
from datetime import datetime
try:
    if not hasattr(builtins, 'original_print'):
        builtins.original_print = print
        def log(*args, **kwargs):
            timestamp = datetime.now().strftime("[%Y-%m-%d %H:%M:%S]")
            builtins.original_print(f"{timestamp}", *args, **kwargs)
        print = log
except: pass
# ------------------------

import re, asyncio, time, os, gc, threading, sys, random
import uvloop
from telethon import TelegramClient, events, functions
from pybit.unified_trading import HTTP

# CONFIG LOADER
try:
    import config
    print("‚úÖ Kelvin Config loaded.")
except ImportError:
    print("‚ùå CRITICAL: config.py not found.")
    sys.exit(1)

asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

API_ID = getattr(config, 'TELEGRAM_API_ID', None)
API_HASH = getattr(config, 'TELEGRAM_API_HASH', None)
CHANNEL_ID = getattr(config, 'KELVIN_CHANNEL_ID', -1003031831727)

BYBIT_KEY = getattr(config, 'KELVIN_API_KEY', None)
BYBIT_SECRET = getattr(config, 'KELVIN_API_SECRET', None)
RISK_AMOUNT = float(getattr(config, 'KELVIN_RISK_AMOUNT', 500.0))
MAX_POS = float(getattr(config, 'KELVIN_MAX_POS', 50000.0))
TESTNET = str(getattr(config, 'KELVIN_TESTNET', 'False')).lower() == 'true'

sess = HTTP(testnet=TESTNET, api_key=BYBIT_KEY, api_secret=BYBIT_SECRET)
client = TelegramClient('session_kelvin', API_ID, API_HASH)

# SHARED MEMORY
INSTRUMENT_CACHE = {}
PRICE_CACHE = {}
PRICE_LOCK = threading.Lock()
LAST_TRADE_TIME = {}
TRADE_LOCK = threading.Lock()

# -------------------------------------------------------------------------
# üß† PARSER
# -------------------------------------------------------------------------
def parse_kelvin(text):
    try:
        upper_text = text.upper()
        is_signal = any(x in upper_text for x in ["ENTRY", "EP", "TARGET", "TP"])
        if not is_signal: return None

        header_match = re.search(r'(?:\[|\$)?\s*([A-Z0-9]+)\s*/\s*USDT', text, re.IGNORECASE)
        if not header_match: return None
        
        symbol = f"{header_match.group(1)}USDT"
        direction = None
        if "LONG" in upper_text or "BUY" in upper_text: direction = "Buy"
        elif "SHORT" in upper_text or "SELL" in upper_text: direction = "Sell"
        if not direction: return None

        lines = text.split('\n')
        entry, tp, sl = None, None, None

        for line in lines:
            line_up = line.upper()
            if "PERCENTAGE" in line_up or "%" in line_up: continue
            num_match = re.search(r'(?<!\d)(\d+[\.,]\d+|\d{2,})(?!\d)', line.replace(':', ' ').replace('&', ' '))
            val = 0.0
            if num_match:
                try: val = float(num_match.group(0).replace(',', ''))
                except: continue
            
            if val > 0:
                if any(k in line_up for k in ["ENTRY", "ENT", "EP "]) and not entry: entry = val
                elif any(k in line_up for k in ["TARGET", "TP", "TAKE PROFIT"]) and not tp: tp = val
                elif any(k in line_up for k in ["STOPLOSS", "STOP LOSS", "SL", "STOP"]) and not sl: sl = val

        if entry and tp and sl:
            return {"sym": symbol, "side": direction, "entry": entry, "tp": tp, "sl": sl}
        return None
    except: return None

# -------------------------------------------------------------------------
# ‚ö° EXECUTION ENGINE (WITH SMART SPLITTER)
# -------------------------------------------------------------------------
def decimals(n):
    s = "{:.10f}".format(n).rstrip('0')
    return len(s.split('.')[1]) if '.' in s else 0

def update_instrument(d):
    s = d['symbol']
    INSTRUMENT_CACHE[s] = {
        'q': float(d['lotSizeFilter']['qtyStep']),
        't': float(d['priceFilter']['tickSize']),
        'q_dec': decimals(float(d['lotSizeFilter']['qtyStep'])),
        't_dec': decimals(float(d['priceFilter']['tickSize']))
    }

def get_instrument(sym):
    if sym in INSTRUMENT_CACHE: return INSTRUMENT_CACHE[sym]
    try:
        r = sess.get_instruments_info(category="linear", symbol=sym)
        if r['result']['list']: 
            update_instrument(r['result']['list'][0])
            return INSTRUMENT_CACHE[sym]
    except: return None
    return None

def rnd(p, d_obj): return "{:.{prec}f}".format(p, prec=d_obj['t_dec'])
def qty_str(q, d_obj): return "{:.{prec}f}".format(q, prec=d_obj['q_dec'])

def execute_trade(sig):
    gc.disable()
    sym = sig['sym']
    with TRADE_LOCK:
        now = time.time()
        if sym in LAST_TRADE_TIME and (now - LAST_TRADE_TIME[sym] < 30): gc.enable(); return
        LAST_TRADE_TIME[sym] = now

    d = get_instrument(sym)
    if not d: gc.enable(); return

    market_price = 0
    with PRICE_LOCK: market_price = PRICE_CACHE.get(sym, 0)
    
    if market_price == 0:
        for _ in range(3):
            try:
                t = sess.get_tickers(category="linear", symbol=sym)
                market_price = float(t['result']['list'][0]['lastPrice'])
                if market_price > 0: break
            except: time.sleep(0.5)
    
    if market_price == 0: gc.enable(); return

    risk_dist = abs(sig['entry'] - sig['sl'])
    if risk_dist == 0: gc.enable(); return

    qty_raw = RISK_AMOUNT / risk_dist
    total_q = (qty_raw // d['q']) * d['q']
    
    if (total_q * sig['entry']) > MAX_POS:
        total_q = (MAX_POS / sig['entry'] // d['q']) * d['q']

    if total_q == 0: gc.enable(); return

    qty_final = qty_str(total_q, d)
    order_args = {
        "symbol": sym, "side": sig['side'], "orderType": "Limit", 
        "qty": qty_final, "price": rnd(sig['entry'], d), "timeInForce": "GTC",
        "stopLoss": rnd(sig['sl'], d), "takeProfit": rnd(sig['tp'], d)
    }

    if abs(market_price - sig['entry']) / market_price < 0.003: 
        order_args["orderType"] = "Market"
        del order_args["price"]
        print(f"üöÄ FIRING MARKET ORDER for {sym}")

    try:
        print(f"üå°Ô∏è KELVIN TRADING: {sig['side']} {sym} | Risk: ${RISK_AMOUNT} | Qty: {qty_final}")
        resp = sess.place_order(category="linear", **order_args)
        
        if resp['retCode'] == 0: 
            print(f"‚úÖ Order Success: {resp['result']['orderId']}")
        
        elif resp['retCode'] == 10001: # Limit Exceeded
            print(f"‚ö†Ô∏è LIMIT EXCEEDED! Splitting order into 4 chunks...")
            
            chunk_raw = total_q / 4
            chunk_q = (chunk_raw // d['q']) * d['q']
            chunk_str = qty_str(chunk_q, d)
            
            order_args['qty'] = chunk_str
            
            # Fire 4 times
            for i in range(4):
                try:
                    r2 = sess.place_order(category="linear", **order_args)
                    if r2['retCode'] == 0: print(f"   üîπ Chunk {i+1}/4 Placed.")
                    else: print(f"   ‚ùå Chunk {i+1} Failed: {r2['retMsg']}")
                    time.sleep(0.2)
                except Exception as e:
                    print(f"   ‚ùå Chunk Crash: {e}")
                    
        else: 
            print(f"‚ùå Bybit Error: {resp}")

    except Exception as e: print(f"‚ùå Execution Error: {e}")
    gc.enable()

# -------------------------------------------------------------------------
# üïµÔ∏è WORKERS
# -------------------------------------------------------------------------
def price_streamer():
    print("üöÄ Kelvin Streamer Active")
    while True:
        try:
            r = sess.get_tickers(category="linear")
            if 'result' in r:
                with PRICE_LOCK:
                    for i in r['result']['list']: PRICE_CACHE[i['symbol']] = float(i['lastPrice'])
            time.sleep(10)
        except: time.sleep(10)

@client.on(events.NewMessage(chats=CHANNEL_ID))
async def handler(event):
    if not event.text: return
    sig = parse_kelvin(event.raw_text)
    if sig: 
        print(f"üì© Signal Received: {sig['sym']}")
        asyncio.get_running_loop().run_in_executor(None, execute_trade, sig)

# ============================================================================
# NEW HEARTBEAT (KEEPS CONNECTION ALIVE)
# ============================================================================
async def heartbeat_loop():
    print(f"üíì HEARTBEAT STARTED (DC{client.session.dc_id})")
    while True:
        try:
            # 1. Ping Telegram to keep socket open
            await client(functions.PingRequest(ping_id=random.randint(0, 1000000)))
            
            # 2. Print a log every hour (3600s) to prove it's alive in logs
            if time.time() % 28800 < 60:
                print(f"üíì ALIVE: Connected to DC{client.session.dc_id} | {datetime.now().strftime('%H:%M')}")
                
        except Exception as e:
            print(f"üíÄ CONNECTION LOST: {e}")
        
        # Wait 60 seconds before next ping
        await asyncio.sleep(60)

async def main():
    print(f"\nüå°Ô∏è BOT KELVIN ACTIVE (Smart Splitting | Heartbeat Enabled)")
    try:
        r = sess.get_instruments_info(category="linear", limit=1000)
        for i in r['result']['list']:
            if i['quoteCoin'] == 'USDT': update_instrument(i)
        print(f"‚úÖ Instruments Loaded.")
    except: pass
    
    threading.Thread(target=price_streamer, daemon=True).start()
    
    await client.start()
    print(f"üåç Connected to Telegram DC{client.session.dc_id}")
    print("‚úÖ Listening...")
    
    # START HEARTBEAT
    asyncio.create_task(heartbeat_loop())
    
    await client.run_until_disconnected()

if __name__ == '__main__':
    asyncio.run(main())
